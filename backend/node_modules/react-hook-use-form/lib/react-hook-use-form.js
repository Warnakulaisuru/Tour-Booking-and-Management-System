"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useForm = void 0;
const react_1 = require("react");
function useForm(initialData, options) {
    const [data, dispatchData] = react_1.useReducer((state, action) => {
        let newState = Object.assign({}, state);
        newState[action.field] = action.value;
        return newState;
    }, initialData);
    const originalData = Object.assign({}, initialData);
    const staticFunctions = react_1.useRef({
        set: (data) => {
            Object.keys(data).forEach((field) => {
                dispatchData({ field: field, value: data[field] });
            });
        },
        clear: () => {
            Object.keys(initialData).forEach((field) => {
                dispatchData({ field: field, value: initialData[field] });
            });
        }
    });
    /** The default onSubmit, this is so we can overwrite it when the user calls `onSubmit` */
    let onSubmitCallback = (data) => {
        // NOOP
    };
    let validators = {};
    Object.keys(data).forEach((key) => {
        validators[key] = () => true;
    });
    const controlledInput = (field) => {
        const update = (value) => {
            dispatchData({ field, value });
        };
        const valid = () => validators[field](data[field], data);
        const ariaLabel = options && options.ariaModel ? `${options.ariaModel}-${field}` : `${field}`;
        return {
            field,
            value: data[field],
            update,
            valid,
            bind: {
                value: data[field],
                name: field,
                onChange: (e) => update(e.target.value),
                'aria-label': ariaLabel,
                id: ariaLabel
            }
        };
    };
    const onSubmit = (cb) => {
        onSubmitCallback = cb;
    };
    const validate = (field, validator) => {
        validators[field] = validator;
    };
    const valid = (field) => {
        if (field) {
            return validators[field](data[field], data);
        }
        return Object.keys(data).reduce((acc, key) => {
            return acc && validators[key](data[key], data);
        }, true);
    };
    const bind = (field) => {
        return controlledInput(field).bind;
    };
    const label = (field) => {
        const id = options && options.ariaModel ? `${options.ariaModel}-${field}` : `${field}`;
        return {
            for: id
        };
    };
    const formBind = () => {
        return {
            onSubmit: (e) => {
                e.preventDefault();
                onSubmitCallback(data);
            }
        };
    };
    const changed = (field) => {
        if (field) {
            console.dir(originalData);
            return originalData[field] !== data[field];
        }
        return Object.keys(data).reduce((changed, field) => {
            if (changed) {
                return changed;
            }
            return originalData[field] !== data[field];
        }, false);
    };
    return {
        clear: staticFunctions.current.clear,
        controlledInput,
        data,
        onSubmit,
        validate,
        valid,
        bind,
        formBind,
        set: staticFunctions.current.set,
        label,
        changed
    };
}
exports.useForm = useForm;
//# sourceMappingURL=react-hook-use-form.js.map